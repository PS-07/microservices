TICKETING APP

Resources
    User -   { email, password }
    Ticket - { title, price, userId, orderId }
    Order -  { userId, status, ticketId, expiresAt }
    Charge - { orderId, status, amount, stripeId, stripeRefundId }

Services
    auth - everything related to user signup/signin/signout
    tickets - ticket creation/editing
    orders - order creation/editing
    expiration - watches for orders to be created, cancels them after 15 min
    payments - handles payments, cancels order if payment fails, completes if succeeds

Design
    React Client App - Next JS
    Common - Library for common code/middlewares for services
    Services - Node servers with persistent database (MongoDb/Redis)
    NATS Streaming Server - Event bus

Kubernetes
    dir - infra/k8s
    use - the deployments: {service}-depl.yaml uses a image to create pods (containers) that run the service;
          also we create a corresponding ClusterIP service in {service}-depl.yaml;
          a ClusterIP service allows communication to the service from anything else running inside our cluster

Skaffold
    dir - ticketing/skaffold.yaml
    use - it is a config file, if a change is made to:
              - any .yaml file in infra/k8s dir, it will apply it to the cluster
              - any change in code in each service dir (auth/tickets/orders/expiration/payments),
                it will sync all the files in there with appropriate container in the cluster
    run - skaffold dev (in ticketing dir)

Ingress-Nginx
    To access a running server (any pod in our cluster), we can:
        1. set up NodePort service
        2. Ingress service - it has routing rules tied to Nginx
    dir - infra/k8s/ingress-srv.yaml
    use - anytime a request comes in to the cluster, it will be handled by the Ingress service and
          it will be routed off to the appropriate service within the cluster  

Host file edit and security warning
    dir - C:\Windows\System32\drivers\etc\hosts
    Edit the 'hosts' file by adding a line at the bottom:
        {IP} ticketing.dev
    [get the {IP} by running minikube ip command] 

    goto http://ticketing.dev
    when prompted with the 'Your connection is not private' error,
    click anywhere on the page and type 'thisisunsafe' 

User Authentication Strategy
    All the services know how to authenticate a user
    1. User sends a request along with its JWT that was assigned to it during signIn
           the cookie within the request contains JWT (cookie is a transportation mechanism)
           the JWT can be decrypted to get the payload (user info)
    2. The service checks if the JWT is valid to authenticate the user

Decrypting JWT and Secret key
    When we send a request, we get back JWT inside a cookie as a response from the app
    actually we get a base64 string that is generated by JSONify the req.session object that
    contains the actual JWT (see in auth/src/routes/signup.ts)
    go to http://base64decode.org to get the session object (containing JWT)
    go to http://jwt.io to get decrypt the JWT to get the payload (user info - id & email) providing the JWT and secret key
    
    Secret is a kind of object in Kubernetes, which can store {key, value} pairs
    we then assign the secret to environment variables of each services' pod, so all of them can use it
    >  kubectl create secret generic jwt-secret --from-literal=JWT_KEY=asdf (in ticketing)
    >  kubectl get secrets  (to get all secrets)
    also we will edit all the {srevice}-depl.yaml files to add the secret key

Database common response
    since we are using different databases (MongoDb, Redis), we want the response from each db to the app to be same
    i.e. we want a consistent response structure that look like:
        {   "id": "...",
            "email": "..."  }
    for ex. MongoDb returns a structure: { "_id": "...", "email": "...", "password": "...", "__v": "..."}


Auth Service
    Structure
            Route              Method           Body                   Purpose
        /api/users/signup         POST     { email, password }    Sign up for an account
        /api/users/signin         POST     { email, password }    Sign in to an existing account  
        /api/users/signout        POST             {}             Sign out
        /api/users/currentuser    GET             ----            Return info about user

    Initialization
        >  npm init -y
        npm install typescript ts-node-dev express @types/express
        tsc --init
        In 'package.json' file, edit "scripts" tag to look like:
            "scripts": {
                "start": "ts-node-dev --poll src/index.ts"
            }
        >  npm install express-validator
        >  npm install express-async-errors
        >  npm install mongoose
        >  npm install @types/mongoose
        >  npm install cookie-session @types/cookie-session
        >  npm install jsonwebtoken @types/jsonwebtoken
        >  npm install --save-dev @types/jest @types/supertest jest ts-jest supertest mongodb-memory-server
        Dockerfile edit - RUN npm install --only=prod
        package.json edit
            "scripts": {
                "start": "ts-node-dev --poll src/index.ts",
                "test": "jest --watchAll --no-cache"
            },
            "jest": {
                "preset": "ts-jest",
                "testEnvironment": "node",
                "setupFilesAfterEnv": [
                    "./src/test/setup.ts"
                ]
            }
        Run tests - npm run test (in auth dir)

        Goto ticketing.dev/api/users/currentuser
        To remove 'Your connection is not private' error,
        click anywhere on the page and type 'thisisunsafe'
        
        >  kubectl create secret generic jwt-secret --from-literal=JWT_KEY=asdf (in ticketing)
    
    Workflow
        src
            errors
            middlewares
            models - Mongoose User Model
            routes - a file for each 4 routes and it exports the corresponding routers to src/index.ts file
            services
            test

    Error Handling
        error should have a consistent structured response from all servers
        request -> Request Handler -> Error Handling Middleware -> structured error response
        error object structure
            { errors: { message: string, field?: string} [] }
        a CustomError abstract class is created which lays down the structure of every error:
            abstact statusCode: number;
            abstract serializeErrors(): { message: string; field?: string }[];
        every error class will extend the abstact CustomError class (to avoid implementation mistakes)

    Database (MongoDb)
        dir - infra/k8s/auth-mongo-depl.yaml    (deployment for MongoDb database for auth service)
              it creates a pod (a MongoDb instance); also a ClusterIP service to connect to the pod
              port: 27017 (default port for MongoDb)
              mongoose is used to connect to a MongoDb instance (mongoose.connect)

    SignUp
        1. ReactApp(client) makes a request with { email, password }
        2. Check if user with this email exists? if yes, respond with an error (ckeck User Collection in db)
           To access the User Collection, a mongoose User model needs to be created
        3. Hash the password
        4. Create a new User and save it to the db (again mongoose User model will be used)
        5. User is now logged in, send them a cookie that contains a JWT (JSON Web Token)

        User Collection will contain all the users: User#1, User#2, User#3, .... 
        Mongoose User Document - represents one single user
        Mongoose User Model - represents entire User Collection

    SignIn
        1. ReactApp(client) makes a request with { email, password }
        2. Check if user with this email exists? if yes, respond with an error
        3. Compare the password of stored user and the supplied password. if same good, else throw an error
        4. User is now logged in, send them a cookie that contains a JWT (JSON Web Token)
           
    CurrentUser
        1. ReactApp(client) makes a Current User request
        2. Check if the request has 'req.session.jwt' set
        3. If it is not set, or if JWT is invalid, return null
        4. If it is set, and the JWT is valid, send back the info stored in JWT (payload) as
           { currentUser: { id: '...', email: '...' } }  

    SignOut
        1. ReactApp(client) makes a SignOut request
        2. Destroy the session

    Testing
        We are running the tests directly from the terminal without using docker
        dir - test files of each dir will be in __test__ dir inside the dir
        Run command: >  npm run test         (in auth dir)
        It will start a test runner called Jest that will execute the tests
            1. Start in-memory copy of MongoDb
            2. Start up the express app
            3. Use supertest lib to make requests
            4. Run assertions to make sure the request did the right thing
        
        The index.js file is refractored to separate the app part in app.js
        app.js - express app that is not listening on any port
        index.js - import app.js, start app, and listen on port 3000
        test files - ipmort app.js, test app with supertest listening on some random port 
                     (so we can perform multiple services' test in parallel on different ports)
        
        The testing Initialization is done with the --save-dev so that we don't have to reinstall it (since it is large)
        The Dockerfile edit: [ RUN npm install--only=prod ] will ensure the command runs only in production mode


Server Side Redndering (NextJS)
    When user types 'ticketing.dev' in browser, the browser sends a 'GET ticketing.dev' request.
    NextJS inspects the URL and determines which component to show (in client/pages dir)
    Call those component's 'getInitialProps' static method (any data retured from it will be passed as props to the component)
    Render each component with data from getInitialProps one time 
    Finally NextJS sends a response back to the browser as a fully rendered HTML file with content

Fetching data during SSR
    Request by browser
        When browser makes a request, say [GET /api/users/currentuser],
        the browser adds a baseUrl: [https://ticketing.dev/api/users/currentuser],
        then network layer changes it to: [https://{minikube ip}/api/users/currentuser],
        and it is forwarded to Ingress-Nginx, and then to appropriate service

    Request by server (in Client pod)
        Problem
        When server (NextJS app) makes a request, say [GET /api/users/currentuser],
        the node's networking layer adds a default baseUrl: [GET localhost:80/api/users/currentuser],
        but since the NextJS app is inside a container, localhost:80 is inside the container, not the browser
        and since nothing is listening on localhost:80 inside the container, we get an error

        Solution
        The NextJS app should reach out to Ingress-Nginx, which is running inside the cluster
        then Ingress-Nginx will figure out the domain based on the request
            
            Cross Namespace Communication
            Within a namespace, pods can communicate using ClusterIP service
            here we have two namespaces (in minikube):
                default: pods running - client, auth, etc. (all microservices)
                kube-system: pods running - nginx-ingress-controller-{id}
            communication protocol: http://SERVICENAME.NAMESPACE.svc.cluster.local (general)
            it's a bit different in minikube:
            Get Ingress-Nginx namespace: (kube-system)
                >  kubectl get namespaces
            Get pod: (nginx-ingress-controller-{id}) 
                >  kubectl get pods -n kube-system
            Get IP_address:
                >  kubectl describe pod nginx-ingress-controller-{id} -n kube-system
            communication protocol: http://IP_address
        
    Hence we can use different baseUrl depending on which environment we're in (browser/server)
    To check whether in browser/server: window variable is only defined in browser

Calling getInitialProps
    getInitialProps is executed on server when:
        1. Hard refresh on page
        2. Clicking link from different domain
        3. Typing URL into address bar
    getInitialProps is executed on browser when:
        1. Navigating from one page to another while in the app

Handling multiple getInitialProps
    getInitialProps has different meaning of context in:
        page component - context === { req,res }
        app component  - context === { Component, ctx: { req, res } }
    so we will fetch the data in app component's getInitialProps and then pass
    down the necessary props to the getInitialProps of the page components that requires it


Client
    Initialization
        >  npm init -y
        >  npm install react react-dom next
        package.json edit
            "scripts": {
                "dev": "next"
            },
        >  docker build -t ps07/client .
        >  docker push ps07/client
        >  npm install bootstrap
        >  npm install axios

    Workflow
        pages - every file inside pages is a route 
                ex. abc.js points to the route https://ticketing.dev//abc
                except index.js points to the default route https://ticketing.dev
        hooks

    File change detection
        NextJS sometimes does not capture a file change when running inside a docker container
        To fix this issue, a 'next.config.js' file is created which polls all the files every 300ms
        rather than looking for any file changes.
        To apply this file, kill the client pod and it will automatically restart with this file applied

    Global CSS (Bootstrap)
        To import any Global CSS such as Bootstrap, it should be included only in 'pages/_app.js' file
        This will apply Bootstrap to every page inside the pages dir
    
    The useRequest hook
        dir - hooks/use-request.js
        use - a generalized hook for all kinds of requests such as get, post etc.
              input - { url, method, body, onSuccess }
              output - { doRequest, errors }

    BuildClient API
        dir - api/build-client.js
        use - takes an incoming request and returns a preconfigured version of axios
              server - sets baseUrl: http://IP_address (from Ingress-Nginx pod), sets header (cookie)
              browser - sets baseUrl: /

    AppComponent
        dir - pages/_app.js
        use - to show elements that would be visible on every single page such as Bootstrap and header

Code Sharing
    To share code between our microservices, create a NPM registry
    Login at http://npmjs.com and 'Add Organiztion' - pstickets (public)

Common
    Initialization
        >  npm init -y
        package.json edit:
            "name": "@pstickets/common"
        >  npm login